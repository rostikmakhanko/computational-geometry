package hermite;

import java.awt.*;
import java.awt.geom.Point2D;
import java.util.ArrayList;

public class HermiteSpline {
    private ArrayList<Point2D> inputDerivatives;
    private ArrayList<Point2D> controlPoints;
    private ArrayList<Point2D> discreteCurveRepresentationPointSetOrdered;
    private boolean useInputDerivatives = false;

    private final double SMALL_VALUE = 0.001;

    public HermiteSpline(ArrayList<Point2D> controlPoints, ArrayList<Point2D> derivatives,
                         boolean useInputDerivatives) throws Exception {
        if (controlPoints == null){
            throw new Exception("POINT SET IS NULL!");
        }
        if (useInputDerivatives){
            if (derivatives == null || (derivatives.size() != controlPoints.size())){
                throw new Exception("IN USE_DERIVATIVES MODE derivatives NULL or not relevant size");
            }
            this.useInputDerivatives = true;
        }

        this.controlPoints = controlPoints;
        this.inputDerivatives = derivatives;
        discreteCurveRepresentationPointSetOrdered = new ArrayList<>();
    }

    public ArrayList<Point2D> getControlPoints() {
        return controlPoints;
    }

    public void generatePoints(){
        this.discreteCurveRepresentationPointSetOrdered = new ArrayList<>();
        if (this.useInputDerivatives){
            generatePointsWithInputDerivatives();
        } else {
            generatePointsDerivativesAutogenerated();
        }
    }

    private void generatePointsWithInputDerivatives(){
        for (int i = 0; i < controlPoints.size() - 1; i++){
            double t = 0.0;
            while(t <= 1.0){
                discreteCurveRepresentationPointSetOrdered.add(computePointByT(
                        controlPoints.get(i), controlPoints.get(i + 1),
                        inputDerivatives.get(i),
                        inputDerivatives.get(i + 1), t
                ));
                t += 0.01;
            }
        }
    }

    private void generatePointsDerivativesAutogenerated(){
        ArrayList<Point2D> derivatives = new ArrayList<>();
        for (int i = 0; i < controlPoints.size(); i++) {
            boolean isFirst = i == 0;
            boolean isLast = i == controlPoints.size() - 1;
            derivatives.add(derivativeInPoint(
                    controlPoints.get(i),
                    isFirst ? null : controlPoints.get(i - 1),
                    isLast ? null : controlPoints.get(i + 1),
                    isLast, isFirst
            ));
        }

        //interval quantity
        for (int i = 0; i < controlPoints.size() - 1; i++) {
            double t = 0.0;

            boolean isLast = (i == controlPoints.size() - 1);
            boolean isFirst = (i == 0);

            while(t <= 1.0){
                discreteCurveRepresentationPointSetOrdered.add(computePointByT(
                    controlPoints.get(i), controlPoints.get(i + 1),
                    derivatives.get(i),
                    derivatives.get(i + 1), t
                ));

                t += 0.01;
            }
        }
    }

    private double basisFunction1(double t){
        return 2 * t * t * t - 3 * t * t + 1.0;
    }

    private double basisFunction2(double t){
        return  -2 * t * t * t + 3 * t * t;
    }

    private double basisFunction3(double t){
        return t * t * t - 2 * t * t + t;
    }

    private double basisFunction4(double t){
        return t * t * t - t * t;
    }

    /**
     * Tangent of p = s*(next - prev), where is s is commonly equals to 1/2 = 0.5
     * */
    private Point2D derivativeInPoint(Point2D p, Point2D prev, Point2D next, boolean isLast, boolean isFirst){
        if (isFirst){
            return new Point.Double((next.getX() - (p.getX() - SMALL_VALUE)) / 2,
                    (next.getY() - p.getY() ) / 2);
        } else if (isLast){
            return new Point.Double(((p.getX() + SMALL_VALUE) - prev.getX()) / 2,
                    (p.getY() - prev.getY()) / 2);
        } else {
            return new Point.Double((next.getX() - prev.getX()) / 2,
                    (next.getY() - prev.getY()) / 2);
        }
    }

    /**
     * Vectors of basis functions and [p1,p2,p1Tan,p2Tan] multiplied
     * */
    private Point2D computePointByT(Point2D p1, Point2D p2, Point2D p1Tan, Point2D p2Tan, double t){
        double x = 0.0, y = 0.0;
        x = basisFunction1(t) * p1.getX() +  basisFunction2(t) * p2.getX() +
                basisFunction3(t) * p1Tan.getX() +  basisFunction4(t) * p2Tan.getX();
        y = basisFunction1(t) * p1.getY() +  basisFunction2(t) * p2.getY() +
                basisFunction3(t) * p1Tan.getY() +  basisFunction4(t) * p2Tan.getY();

        return new Point2D.Double(x, y);
    }


    public ArrayList<Point2D> getCurvePoints(){
        return this.discreteCurveRepresentationPointSetOrdered;
    }
}
